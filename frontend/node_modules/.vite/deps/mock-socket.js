import {
  __commonJS,
  __require
} from "./chunk-VUNV25KB.js";

// node_modules/mock-socket/dist/mock-socket.js
var require_mock_socket = __commonJS({
  "node_modules/mock-socket/dist/mock-socket.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.Mock = global2.Mock || {});
    })(exports, (function(exports2) {
      "use strict";
      var commonjsGlobal = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var requiresPort = function required(port, protocol) {
        protocol = protocol.split(":")[0];
        port = +port;
        if (!port) {
          return false;
        }
        switch (protocol) {
          case "http":
          case "ws":
            return port !== 80;
          case "https":
          case "wss":
            return port !== 443;
          case "ftp":
            return port !== 21;
          case "gopher":
            return port !== 70;
          case "file":
            return false;
        }
        return port !== 0;
      };
      var has = Object.prototype.hasOwnProperty;
      var undef;
      function decode(input) {
        try {
          return decodeURIComponent(input.replace(/\+/g, " "));
        } catch (e) {
          return null;
        }
      }
      function encode(input) {
        try {
          return encodeURIComponent(input);
        } catch (e) {
          return null;
        }
      }
      function querystring(query) {
        var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
        while (part = parser.exec(query)) {
          var key = decode(part[1]), value = decode(part[2]);
          if (key === null || value === null || key in result) {
            continue;
          }
          result[key] = value;
        }
        return result;
      }
      function querystringify(obj, prefix) {
        prefix = prefix || "";
        var pairs = [], value, key;
        if ("string" !== typeof prefix) {
          prefix = "?";
        }
        for (key in obj) {
          if (has.call(obj, key)) {
            value = obj[key];
            if (!value && (value === null || value === undef || isNaN(value))) {
              value = "";
            }
            key = encode(key);
            value = encode(value);
            if (key === null || value === null) {
              continue;
            }
            pairs.push(key + "=" + value);
          }
        }
        return pairs.length ? prefix + pairs.join("&") : "";
      }
      var stringify = querystringify;
      var parse = querystring;
      var querystringify_1 = {
        stringify,
        parse
      };
      var CRHTLF = /[\n\r\t]/g;
      var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
      var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
      var windowsDriveLetter = /^[a-zA-Z]:/;
      var whitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      function trimLeft(str) {
        return (str ? str : "").toString().replace(whitespace, "");
      }
      var rules = [
        ["#", "hash"],
        // Extract from the back.
        ["?", "query"],
        // Extract from the back.
        function sanitize(address, url) {
          return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
        },
        ["/", "pathname"],
        // Extract from the back.
        ["@", "auth", 1],
        // Extract from the front.
        [NaN, "host", void 0, 1, 1],
        // Set left over value.
        [/:(\d*)$/, "port", void 0, 1],
        // RegExp the back.
        [NaN, "hostname", void 0, 1, 1]
        // Set left over.
      ];
      var ignore = { hash: 1, query: 1 };
      function lolcation(loc) {
        var globalVar;
        if (typeof window !== "undefined") {
          globalVar = window;
        } else if (typeof commonjsGlobal !== "undefined") {
          globalVar = commonjsGlobal;
        } else if (typeof self !== "undefined") {
          globalVar = self;
        } else {
          globalVar = {};
        }
        var location = globalVar.location || {};
        loc = loc || location;
        var finaldestination = {}, type = typeof loc, key;
        if ("blob:" === loc.protocol) {
          finaldestination = new Url(unescape(loc.pathname), {});
        } else if ("string" === type) {
          finaldestination = new Url(loc, {});
          for (key in ignore) {
            delete finaldestination[key];
          }
        } else if ("object" === type) {
          for (key in loc) {
            if (key in ignore) {
              continue;
            }
            finaldestination[key] = loc[key];
          }
          if (finaldestination.slashes === void 0) {
            finaldestination.slashes = slashes.test(loc.href);
          }
        }
        return finaldestination;
      }
      function isSpecial(scheme) {
        return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
      }
      function extractProtocol(address, location) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        location = location || {};
        var match = protocolre.exec(address);
        var protocol = match[1] ? match[1].toLowerCase() : "";
        var forwardSlashes = !!match[2];
        var otherSlashes = !!match[3];
        var slashesCount = 0;
        var rest;
        if (forwardSlashes) {
          if (otherSlashes) {
            rest = match[2] + match[3] + match[4];
            slashesCount = match[2].length + match[3].length;
          } else {
            rest = match[2] + match[4];
            slashesCount = match[2].length;
          }
        } else {
          if (otherSlashes) {
            rest = match[3] + match[4];
            slashesCount = match[3].length;
          } else {
            rest = match[4];
          }
        }
        if (protocol === "file:") {
          if (slashesCount >= 2) {
            rest = rest.slice(2);
          }
        } else if (isSpecial(protocol)) {
          rest = match[4];
        } else if (protocol) {
          if (forwardSlashes) {
            rest = rest.slice(2);
          }
        } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
          rest = match[4];
        }
        return {
          protocol,
          slashes: forwardSlashes || isSpecial(protocol),
          slashesCount,
          rest
        };
      }
      function resolve(relative, base) {
        if (relative === "") {
          return base;
        }
        var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
        while (i--) {
          if (path[i] === ".") {
            path.splice(i, 1);
          } else if (path[i] === "..") {
            path.splice(i, 1);
            up++;
          } else if (up) {
            if (i === 0) {
              unshift = true;
            }
            path.splice(i, 1);
            up--;
          }
        }
        if (unshift) {
          path.unshift("");
        }
        if (last === "." || last === "..") {
          path.push("");
        }
        return path.join("/");
      }
      function Url(address, location, parser) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        if (!(this instanceof Url)) {
          return new Url(address, location, parser);
        }
        var relative, extracted, parse2, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
        if ("object" !== type && "string" !== type) {
          parser = location;
          location = null;
        }
        if (parser && "function" !== typeof parser) {
          parser = querystringify_1.parse;
        }
        location = lolcation(location);
        extracted = extractProtocol(address || "", location);
        relative = !extracted.protocol && !extracted.slashes;
        url.slashes = extracted.slashes || relative && location.slashes;
        url.protocol = extracted.protocol || location.protocol || "";
        address = extracted.rest;
        if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
          instructions[3] = [/(.*)/, "pathname"];
        }
        for (; i < instructions.length; i++) {
          instruction = instructions[i];
          if (typeof instruction === "function") {
            address = instruction(address, url);
            continue;
          }
          parse2 = instruction[0];
          key = instruction[1];
          if (parse2 !== parse2) {
            url[key] = address;
          } else if ("string" === typeof parse2) {
            index = parse2 === "@" ? address.lastIndexOf(parse2) : address.indexOf(parse2);
            if (~index) {
              if ("number" === typeof instruction[2]) {
                url[key] = address.slice(0, index);
                address = address.slice(index + instruction[2]);
              } else {
                url[key] = address.slice(index);
                address = address.slice(0, index);
              }
            }
          } else if (index = parse2.exec(address)) {
            url[key] = index[1];
            address = address.slice(0, index.index);
          }
          url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
          if (instruction[4]) {
            url[key] = url[key].toLowerCase();
          }
        }
        if (parser) {
          url.query = parser(url.query);
        }
        if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
          url.pathname = resolve(url.pathname, location.pathname);
        }
        if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
          url.pathname = "/" + url.pathname;
        }
        if (!requiresPort(url.port, url.protocol)) {
          url.host = url.hostname;
          url.port = "";
        }
        url.username = url.password = "";
        if (url.auth) {
          index = url.auth.indexOf(":");
          if (~index) {
            url.username = url.auth.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = url.auth.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(url.auth));
          }
          url.auth = url.password ? url.username + ":" + url.password : url.username;
        }
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
      }
      function set(part, value, fn) {
        var url = this;
        switch (part) {
          case "query":
            if ("string" === typeof value && value.length) {
              value = (fn || querystringify_1.parse)(value);
            }
            url[part] = value;
            break;
          case "port":
            url[part] = value;
            if (!requiresPort(value, url.protocol)) {
              url.host = url.hostname;
              url[part] = "";
            } else if (value) {
              url.host = url.hostname + ":" + value;
            }
            break;
          case "hostname":
            url[part] = value;
            if (url.port) {
              value += ":" + url.port;
            }
            url.host = value;
            break;
          case "host":
            url[part] = value;
            if (/:\d+$/.test(value)) {
              value = value.split(":");
              url.port = value.pop();
              url.hostname = value.join(":");
            } else {
              url.hostname = value;
              url.port = "";
            }
            break;
          case "protocol":
            url.protocol = value.toLowerCase();
            url.slashes = !fn;
            break;
          case "pathname":
          case "hash":
            if (value) {
              var char = part === "pathname" ? "/" : "#";
              url[part] = value.charAt(0) !== char ? char + value : value;
            } else {
              url[part] = value;
            }
            break;
          case "username":
          case "password":
            url[part] = encodeURIComponent(value);
            break;
          case "auth":
            var index = value.indexOf(":");
            if (~index) {
              url.username = value.slice(0, index);
              url.username = encodeURIComponent(decodeURIComponent(url.username));
              url.password = value.slice(index + 1);
              url.password = encodeURIComponent(decodeURIComponent(url.password));
            } else {
              url.username = encodeURIComponent(decodeURIComponent(value));
            }
        }
        for (var i = 0; i < rules.length; i++) {
          var ins = rules[i];
          if (ins[4]) {
            url[ins[1]] = url[ins[1]].toLowerCase();
          }
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
        return url;
      }
      function toString(stringify2) {
        if (!stringify2 || "function" !== typeof stringify2) {
          stringify2 = querystringify_1.stringify;
        }
        var query, url = this, host = url.host, protocol = url.protocol;
        if (protocol && protocol.charAt(protocol.length - 1) !== ":") {
          protocol += ":";
        }
        var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
        if (url.username) {
          result += url.username;
          if (url.password) {
            result += ":" + url.password;
          }
          result += "@";
        } else if (url.password) {
          result += ":" + url.password;
          result += "@";
        } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
          result += "@";
        }
        if (host[host.length - 1] === ":") {
          host += ":";
        }
        result += host + url.pathname;
        query = "object" === typeof url.query ? stringify2(url.query) : url.query;
        if (query) {
          result += "?" !== query.charAt(0) ? "?" + query : query;
        }
        if (url.hash) {
          result += url.hash;
        }
        return result;
      }
      Url.prototype = { set, toString };
      Url.extractProtocol = extractProtocol;
      Url.location = lolcation;
      Url.trimLeft = trimLeft;
      Url.qs = querystringify_1;
      var urlParse = Url;
      function delay(callback, context) {
        setTimeout(function(timeoutContext) {
          return callback.call(timeoutContext);
        }, 4, context);
      }
      function log(method, message) {
        if (typeof process !== "undefined" && true) {
          console[method].call(null, message);
        }
      }
      function reject(array, callback) {
        if (array === void 0) array = [];
        var results = [];
        array.forEach(function(itemInArray) {
          if (!callback(itemInArray)) {
            results.push(itemInArray);
          }
        });
        return results;
      }
      function filter(array, callback) {
        if (array === void 0) array = [];
        var results = [];
        array.forEach(function(itemInArray) {
          if (callback(itemInArray)) {
            results.push(itemInArray);
          }
        });
        return results;
      }
      var EventTarget = function EventTarget2() {
        this.listeners = {};
      };
      EventTarget.prototype.addEventListener = function addEventListener(type, listener) {
        if (typeof listener === "function") {
          if (!Array.isArray(this.listeners[type])) {
            this.listeners[type] = [];
          }
          if (filter(this.listeners[type], function(item) {
            return item === listener;
          }).length === 0) {
            this.listeners[type].push(listener);
          }
        }
      };
      EventTarget.prototype.removeEventListener = function removeEventListener(type, removingListener) {
        var arrayOfListeners = this.listeners[type];
        this.listeners[type] = reject(arrayOfListeners, function(listener) {
          return listener === removingListener;
        });
      };
      EventTarget.prototype.dispatchEvent = function dispatchEvent(event) {
        var this$1 = this;
        var customArguments = [], len = arguments.length - 1;
        while (len-- > 0) customArguments[len] = arguments[len + 1];
        var eventName = event.type;
        var listeners = this.listeners[eventName];
        if (!Array.isArray(listeners)) {
          return false;
        }
        listeners.forEach(function(listener) {
          if (customArguments.length > 0) {
            listener.apply(this$1, customArguments);
          } else {
            listener.call(this$1, event);
          }
        });
        return true;
      };
      function trimQueryPartFromURL(url) {
        var queryIndex = url.indexOf("?");
        return queryIndex >= 0 ? url.slice(0, queryIndex) : url;
      }
      var NetworkBridge = function NetworkBridge2() {
        this.urlMap = {};
      };
      NetworkBridge.prototype.attachWebSocket = function attachWebSocket(websocket, url) {
        var serverURL = trimQueryPartFromURL(url);
        var connectionLookup = this.urlMap[serverURL];
        if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) === -1) {
          connectionLookup.websockets.push(websocket);
          return connectionLookup.server;
        }
      };
      NetworkBridge.prototype.addMembershipToRoom = function addMembershipToRoom(websocket, room) {
        var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];
        if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) !== -1) {
          if (!connectionLookup.roomMemberships[room]) {
            connectionLookup.roomMemberships[room] = [];
          }
          connectionLookup.roomMemberships[room].push(websocket);
        }
      };
      NetworkBridge.prototype.attachServer = function attachServer(server, url) {
        var serverUrl = trimQueryPartFromURL(url);
        var connectionLookup = this.urlMap[serverUrl];
        if (!connectionLookup) {
          this.urlMap[serverUrl] = {
            server,
            websockets: [],
            roomMemberships: {}
          };
          return server;
        }
      };
      NetworkBridge.prototype.serverLookup = function serverLookup(url) {
        var serverURL = trimQueryPartFromURL(url);
        var connectionLookup = this.urlMap[serverURL];
        if (connectionLookup) {
          return connectionLookup.server;
        }
      };
      NetworkBridge.prototype.websocketsLookup = function websocketsLookup(url, room, broadcaster) {
        var serverURL = trimQueryPartFromURL(url);
        var websockets;
        var connectionLookup = this.urlMap[serverURL];
        websockets = connectionLookup ? connectionLookup.websockets : [];
        if (room) {
          var members = connectionLookup.roomMemberships[room];
          websockets = members || [];
        }
        return broadcaster ? websockets.filter(function(websocket) {
          return websocket !== broadcaster;
        }) : websockets;
      };
      NetworkBridge.prototype.removeServer = function removeServer(url) {
        delete this.urlMap[trimQueryPartFromURL(url)];
      };
      NetworkBridge.prototype.removeWebSocket = function removeWebSocket(websocket, url) {
        var serverURL = trimQueryPartFromURL(url);
        var connectionLookup = this.urlMap[serverURL];
        if (connectionLookup) {
          connectionLookup.websockets = reject(connectionLookup.websockets, function(socket) {
            return socket === websocket;
          });
        }
      };
      NetworkBridge.prototype.removeMembershipFromRoom = function removeMembershipFromRoom(websocket, room) {
        var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];
        var memberships = connectionLookup.roomMemberships[room];
        if (connectionLookup && memberships !== null) {
          connectionLookup.roomMemberships[room] = reject(memberships, function(socket) {
            return socket === websocket;
          });
        }
      };
      var networkBridge = new NetworkBridge();
      var CLOSE_CODES = {
        CLOSE_NORMAL: 1e3,
        CLOSE_GOING_AWAY: 1001,
        CLOSE_PROTOCOL_ERROR: 1002,
        CLOSE_UNSUPPORTED: 1003,
        CLOSE_NO_STATUS: 1005,
        CLOSE_ABNORMAL: 1006,
        UNSUPPORTED_DATA: 1007,
        POLICY_VIOLATION: 1008,
        CLOSE_TOO_LARGE: 1009,
        MISSING_EXTENSION: 1010,
        INTERNAL_ERROR: 1011,
        SERVICE_RESTART: 1012,
        TRY_AGAIN_LATER: 1013,
        TLS_HANDSHAKE: 1015
      };
      var ERROR_PREFIX = {
        CONSTRUCTOR_ERROR: "Failed to construct 'WebSocket':",
        CLOSE_ERROR: "Failed to execute 'close' on 'WebSocket':",
        EVENT: {
          CONSTRUCT: "Failed to construct 'Event':",
          MESSAGE: "Failed to construct 'MessageEvent':",
          CLOSE: "Failed to construct 'CloseEvent':"
        }
      };
      var EventPrototype = function EventPrototype2() {
      };
      EventPrototype.prototype.stopPropagation = function stopPropagation() {
      };
      EventPrototype.prototype.stopImmediatePropagation = function stopImmediatePropagation() {
      };
      EventPrototype.prototype.initEvent = function initEvent(type, bubbles, cancelable) {
        if (type === void 0) type = "undefined";
        if (bubbles === void 0) bubbles = false;
        if (cancelable === void 0) cancelable = false;
        this.type = "" + type;
        this.bubbles = Boolean(bubbles);
        this.cancelable = Boolean(cancelable);
      };
      var Event = (function(EventPrototype$$1) {
        function Event2(type, eventInitConfig) {
          if (eventInitConfig === void 0) eventInitConfig = {};
          EventPrototype$$1.call(this);
          if (!type) {
            throw new TypeError(ERROR_PREFIX.EVENT_ERROR + " 1 argument required, but only 0 present.");
          }
          if (typeof eventInitConfig !== "object") {
            throw new TypeError(ERROR_PREFIX.EVENT_ERROR + " parameter 2 ('eventInitDict') is not an object.");
          }
          var bubbles = eventInitConfig.bubbles;
          var cancelable = eventInitConfig.cancelable;
          this.type = "" + type;
          this.timeStamp = Date.now();
          this.target = null;
          this.srcElement = null;
          this.returnValue = true;
          this.isTrusted = false;
          this.eventPhase = 0;
          this.defaultPrevented = false;
          this.currentTarget = null;
          this.cancelable = cancelable ? Boolean(cancelable) : false;
          this.cancelBubble = false;
          this.bubbles = bubbles ? Boolean(bubbles) : false;
        }
        if (EventPrototype$$1) Event2.__proto__ = EventPrototype$$1;
        Event2.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);
        Event2.prototype.constructor = Event2;
        return Event2;
      })(EventPrototype);
      var MessageEvent = (function(EventPrototype$$1) {
        function MessageEvent2(type, eventInitConfig) {
          if (eventInitConfig === void 0) eventInitConfig = {};
          EventPrototype$$1.call(this);
          if (!type) {
            throw new TypeError(ERROR_PREFIX.EVENT.MESSAGE + " 1 argument required, but only 0 present.");
          }
          if (typeof eventInitConfig !== "object") {
            throw new TypeError(ERROR_PREFIX.EVENT.MESSAGE + " parameter 2 ('eventInitDict') is not an object");
          }
          var bubbles = eventInitConfig.bubbles;
          var cancelable = eventInitConfig.cancelable;
          var data = eventInitConfig.data;
          var origin = eventInitConfig.origin;
          var lastEventId = eventInitConfig.lastEventId;
          var ports = eventInitConfig.ports;
          this.type = "" + type;
          this.timeStamp = Date.now();
          this.target = null;
          this.srcElement = null;
          this.returnValue = true;
          this.isTrusted = false;
          this.eventPhase = 0;
          this.defaultPrevented = false;
          this.currentTarget = null;
          this.cancelable = cancelable ? Boolean(cancelable) : false;
          this.canncelBubble = false;
          this.bubbles = bubbles ? Boolean(bubbles) : false;
          this.origin = "" + origin;
          this.ports = typeof ports === "undefined" ? null : ports;
          this.data = typeof data === "undefined" ? null : data;
          this.lastEventId = "" + (lastEventId || "");
        }
        if (EventPrototype$$1) MessageEvent2.__proto__ = EventPrototype$$1;
        MessageEvent2.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);
        MessageEvent2.prototype.constructor = MessageEvent2;
        return MessageEvent2;
      })(EventPrototype);
      var CloseEvent = (function(EventPrototype$$1) {
        function CloseEvent2(type, eventInitConfig) {
          if (eventInitConfig === void 0) eventInitConfig = {};
          EventPrototype$$1.call(this);
          if (!type) {
            throw new TypeError(ERROR_PREFIX.EVENT.CLOSE + " 1 argument required, but only 0 present.");
          }
          if (typeof eventInitConfig !== "object") {
            throw new TypeError(ERROR_PREFIX.EVENT.CLOSE + " parameter 2 ('eventInitDict') is not an object");
          }
          var bubbles = eventInitConfig.bubbles;
          var cancelable = eventInitConfig.cancelable;
          var code = eventInitConfig.code;
          var reason = eventInitConfig.reason;
          var wasClean = eventInitConfig.wasClean;
          this.type = "" + type;
          this.timeStamp = Date.now();
          this.target = null;
          this.srcElement = null;
          this.returnValue = true;
          this.isTrusted = false;
          this.eventPhase = 0;
          this.defaultPrevented = false;
          this.currentTarget = null;
          this.cancelable = cancelable ? Boolean(cancelable) : false;
          this.cancelBubble = false;
          this.bubbles = bubbles ? Boolean(bubbles) : false;
          this.code = typeof code === "number" ? parseInt(code, 10) : 0;
          this.reason = "" + (reason || "");
          this.wasClean = wasClean ? Boolean(wasClean) : false;
        }
        if (EventPrototype$$1) CloseEvent2.__proto__ = EventPrototype$$1;
        CloseEvent2.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);
        CloseEvent2.prototype.constructor = CloseEvent2;
        return CloseEvent2;
      })(EventPrototype);
      function createEvent(config) {
        var type = config.type;
        var target = config.target;
        var eventObject = new Event(type);
        if (target) {
          eventObject.target = target;
          eventObject.srcElement = target;
          eventObject.currentTarget = target;
        }
        return eventObject;
      }
      function createMessageEvent(config) {
        var type = config.type;
        var origin = config.origin;
        var data = config.data;
        var target = config.target;
        var messageEvent = new MessageEvent(type, {
          data,
          origin
        });
        if (target) {
          messageEvent.target = target;
          messageEvent.srcElement = target;
          messageEvent.currentTarget = target;
        }
        return messageEvent;
      }
      function createCloseEvent(config) {
        var code = config.code;
        var reason = config.reason;
        var type = config.type;
        var target = config.target;
        var wasClean = config.wasClean;
        if (!wasClean) {
          wasClean = code === CLOSE_CODES.CLOSE_NORMAL || code === CLOSE_CODES.CLOSE_NO_STATUS;
        }
        var closeEvent = new CloseEvent(type, {
          code,
          reason,
          wasClean
        });
        if (target) {
          closeEvent.target = target;
          closeEvent.srcElement = target;
          closeEvent.currentTarget = target;
        }
        return closeEvent;
      }
      function closeWebSocketConnection(context, code, reason) {
        context.readyState = WebSocket$1.CLOSING;
        var server = networkBridge.serverLookup(context.url);
        var closeEvent = createCloseEvent({
          type: "close",
          target: context.target,
          code,
          reason
        });
        delay(function() {
          networkBridge.removeWebSocket(context, context.url);
          context.readyState = WebSocket$1.CLOSED;
          context.dispatchEvent(closeEvent);
          if (server) {
            server.dispatchEvent(closeEvent, server);
          }
        }, context);
      }
      function failWebSocketConnection(context, code, reason) {
        context.readyState = WebSocket$1.CLOSING;
        var server = networkBridge.serverLookup(context.url);
        var closeEvent = createCloseEvent({
          type: "close",
          target: context.target,
          code,
          reason,
          wasClean: false
        });
        var errorEvent = createEvent({
          type: "error",
          target: context.target
        });
        delay(function() {
          networkBridge.removeWebSocket(context, context.url);
          context.readyState = WebSocket$1.CLOSED;
          context.dispatchEvent(errorEvent);
          context.dispatchEvent(closeEvent);
          if (server) {
            server.dispatchEvent(closeEvent, server);
          }
        }, context);
      }
      function normalizeSendData(data) {
        if (Object.prototype.toString.call(data) !== "[object Blob]" && !(data instanceof ArrayBuffer)) {
          data = String(data);
        }
        return data;
      }
      var proxies = /* @__PURE__ */ new WeakMap();
      function proxyFactory(target) {
        if (proxies.has(target)) {
          return proxies.get(target);
        }
        var proxy = new Proxy(target, {
          get: function get(obj, prop) {
            if (prop === "close") {
              return function close(options) {
                if (options === void 0) options = {};
                var code = options.code || CLOSE_CODES.CLOSE_NORMAL;
                var reason = options.reason || "";
                closeWebSocketConnection(proxy, code, reason);
              };
            }
            if (prop === "send") {
              return function send(data) {
                data = normalizeSendData(data);
                target.dispatchEvent(
                  createMessageEvent({
                    type: "message",
                    data,
                    origin: this.url,
                    target
                  })
                );
              };
            }
            var toSocketName = function(type) {
              return type === "message" ? "server::" + type : type;
            };
            if (prop === "on") {
              return function onWrapper(type, cb) {
                target.addEventListener(toSocketName(type), cb);
              };
            }
            if (prop === "off") {
              return function offWrapper(type, cb) {
                target.removeEventListener(toSocketName(type), cb);
              };
            }
            if (prop === "target") {
              return target;
            }
            return obj[prop];
          }
        });
        proxies.set(target, proxy);
        return proxy;
      }
      function lengthInUtf8Bytes(str) {
        var m = encodeURIComponent(str).match(/%[89ABab]/g);
        return str.length + (m ? m.length : 0);
      }
      function urlVerification(url) {
        var urlRecord = new urlParse(url);
        var pathname = urlRecord.pathname;
        var protocol = urlRecord.protocol;
        var hash = urlRecord.hash;
        if (!url) {
          throw new TypeError(ERROR_PREFIX.CONSTRUCTOR_ERROR + " 1 argument required, but only 0 present.");
        }
        if (!pathname) {
          urlRecord.pathname = "/";
        }
        if (protocol === "") {
          throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + " The URL '" + urlRecord.toString() + "' is invalid.");
        }
        if (protocol !== "ws:" && protocol !== "wss:") {
          throw new SyntaxError(
            ERROR_PREFIX.CONSTRUCTOR_ERROR + " The URL's scheme must be either 'ws' or 'wss'. '" + protocol + "' is not allowed."
          );
        }
        if (hash !== "") {
          throw new SyntaxError(
            ERROR_PREFIX.CONSTRUCTOR_ERROR + " The URL contains a fragment identifier ('" + hash + "'). Fragment identifiers are not allowed in WebSocket URLs."
          );
        }
        return urlRecord.toString();
      }
      function protocolVerification(protocols) {
        if (protocols === void 0) protocols = [];
        if (!Array.isArray(protocols) && typeof protocols !== "string") {
          throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + " The subprotocol '" + protocols.toString() + "' is invalid.");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        var uniq = protocols.map(function(p) {
          return { count: 1, protocol: p };
        }).reduce(function(a, b) {
          a[b.protocol] = (a[b.protocol] || 0) + b.count;
          return a;
        }, {});
        var duplicates = Object.keys(uniq).filter(function(a) {
          return uniq[a] > 1;
        });
        if (duplicates.length > 0) {
          throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + " The subprotocol '" + duplicates[0] + "' is duplicated.");
        }
        return protocols;
      }
      var WebSocket$1 = (function(EventTarget$$1) {
        function WebSocket2(url, protocols) {
          EventTarget$$1.call(this);
          this._onopen = null;
          this._onmessage = null;
          this._onerror = null;
          this._onclose = null;
          this.url = urlVerification(url);
          protocols = protocolVerification(protocols);
          this.protocol = protocols[0] || "";
          this.binaryType = "blob";
          this.readyState = WebSocket2.CONNECTING;
          var client = proxyFactory(this);
          var server = networkBridge.attachWebSocket(client, this.url);
          delay(function delayCallback() {
            if (this.readyState !== WebSocket2.CONNECTING) {
              return;
            }
            if (server) {
              if (server.options.verifyClient && typeof server.options.verifyClient === "function" && !server.options.verifyClient()) {
                this.readyState = WebSocket2.CLOSED;
                log(
                  "error",
                  "WebSocket connection to '" + this.url + "' failed: HTTP Authentication failed; no valid credentials available"
                );
                networkBridge.removeWebSocket(client, this.url);
                this.dispatchEvent(createEvent({ type: "error", target: this }));
                this.dispatchEvent(createCloseEvent({ type: "close", target: this, code: CLOSE_CODES.CLOSE_NORMAL }));
              } else {
                if (server.options.selectProtocol && typeof server.options.selectProtocol === "function") {
                  var selectedProtocol = server.options.selectProtocol(protocols);
                  var isFilled = selectedProtocol !== "";
                  var isRequested = protocols.indexOf(selectedProtocol) !== -1;
                  if (isFilled && !isRequested) {
                    this.readyState = WebSocket2.CLOSED;
                    log("error", "WebSocket connection to '" + this.url + "' failed: Invalid Sub-Protocol");
                    networkBridge.removeWebSocket(client, this.url);
                    this.dispatchEvent(createEvent({ type: "error", target: this }));
                    this.dispatchEvent(createCloseEvent({ type: "close", target: this, code: CLOSE_CODES.CLOSE_NORMAL }));
                    return;
                  }
                  this.protocol = selectedProtocol;
                }
                this.readyState = WebSocket2.OPEN;
                this.dispatchEvent(createEvent({ type: "open", target: this }));
                server.dispatchEvent(createEvent({ type: "connection" }), client);
              }
            } else {
              this.readyState = WebSocket2.CLOSED;
              this.dispatchEvent(createEvent({ type: "error", target: this }));
              this.dispatchEvent(createCloseEvent({ type: "close", target: this, code: CLOSE_CODES.CLOSE_NORMAL }));
              log("error", "WebSocket connection to '" + this.url + "' failed");
            }
          }, this);
        }
        if (EventTarget$$1) WebSocket2.__proto__ = EventTarget$$1;
        WebSocket2.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);
        WebSocket2.prototype.constructor = WebSocket2;
        var prototypeAccessors = { onopen: {}, onmessage: {}, onclose: {}, onerror: {} };
        prototypeAccessors.onopen.get = function() {
          return this._onopen;
        };
        prototypeAccessors.onmessage.get = function() {
          return this._onmessage;
        };
        prototypeAccessors.onclose.get = function() {
          return this._onclose;
        };
        prototypeAccessors.onerror.get = function() {
          return this._onerror;
        };
        prototypeAccessors.onopen.set = function(listener) {
          this.removeEventListener("open", this._onopen);
          this._onopen = listener;
          this.addEventListener("open", listener);
        };
        prototypeAccessors.onmessage.set = function(listener) {
          this.removeEventListener("message", this._onmessage);
          this._onmessage = listener;
          this.addEventListener("message", listener);
        };
        prototypeAccessors.onclose.set = function(listener) {
          this.removeEventListener("close", this._onclose);
          this._onclose = listener;
          this.addEventListener("close", listener);
        };
        prototypeAccessors.onerror.set = function(listener) {
          this.removeEventListener("error", this._onerror);
          this._onerror = listener;
          this.addEventListener("error", listener);
        };
        WebSocket2.prototype.send = function send(data) {
          var this$1 = this;
          if (this.readyState === WebSocket2.CONNECTING) {
            throw new Error("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state");
          }
          var messageEvent = createMessageEvent({
            type: "server::message",
            origin: this.url,
            data: normalizeSendData(data)
          });
          var server = networkBridge.serverLookup(this.url);
          if (server) {
            delay(function() {
              this$1.dispatchEvent(messageEvent, data);
            }, server);
          }
        };
        WebSocket2.prototype.close = function close(code, reason) {
          if (code !== void 0) {
            if (typeof code !== "number" || code !== 1e3 && (code < 3e3 || code > 4999)) {
              throw new TypeError(
                ERROR_PREFIX.CLOSE_ERROR + " The code must be either 1000, or between 3000 and 4999. " + code + " is neither."
              );
            }
          }
          if (reason !== void 0) {
            var length = lengthInUtf8Bytes(reason);
            if (length > 123) {
              throw new SyntaxError(ERROR_PREFIX.CLOSE_ERROR + " The message must not be greater than 123 bytes.");
            }
          }
          if (this.readyState === WebSocket2.CLOSING || this.readyState === WebSocket2.CLOSED) {
            return;
          }
          var client = proxyFactory(this);
          if (this.readyState === WebSocket2.CONNECTING) {
            failWebSocketConnection(client, code || CLOSE_CODES.CLOSE_ABNORMAL, reason);
          } else {
            closeWebSocketConnection(client, code || CLOSE_CODES.CLOSE_NO_STATUS, reason);
          }
        };
        Object.defineProperties(WebSocket2.prototype, prototypeAccessors);
        return WebSocket2;
      })(EventTarget);
      WebSocket$1.CONNECTING = 0;
      WebSocket$1.prototype.CONNECTING = WebSocket$1.CONNECTING;
      WebSocket$1.OPEN = 1;
      WebSocket$1.prototype.OPEN = WebSocket$1.OPEN;
      WebSocket$1.CLOSING = 2;
      WebSocket$1.prototype.CLOSING = WebSocket$1.CLOSING;
      WebSocket$1.CLOSED = 3;
      WebSocket$1.prototype.CLOSED = WebSocket$1.CLOSED;
      var SocketIO$1 = (function(EventTarget$$1) {
        function SocketIO(url, protocol) {
          var this$1 = this;
          if (url === void 0) url = "socket.io";
          if (protocol === void 0) protocol = "";
          EventTarget$$1.call(this);
          this.binaryType = "blob";
          var urlRecord = new urlParse(url);
          if (!urlRecord.pathname) {
            urlRecord.pathname = "/";
          }
          this.url = urlRecord.toString();
          this.readyState = SocketIO.CONNECTING;
          this.protocol = "";
          this.target = this;
          if (typeof protocol === "string" || typeof protocol === "object" && protocol !== null) {
            this.protocol = protocol;
          } else if (Array.isArray(protocol) && protocol.length > 0) {
            this.protocol = protocol[0];
          }
          var server = networkBridge.attachWebSocket(this, this.url);
          delay(function delayCallback() {
            if (server) {
              this.readyState = SocketIO.OPEN;
              server.dispatchEvent(createEvent({ type: "connection" }), server, this);
              server.dispatchEvent(createEvent({ type: "connect" }), server, this);
              this.dispatchEvent(createEvent({ type: "connect", target: this }));
            } else {
              this.readyState = SocketIO.CLOSED;
              this.dispatchEvent(createEvent({ type: "error", target: this }));
              this.dispatchEvent(
                createCloseEvent({
                  type: "close",
                  target: this,
                  code: CLOSE_CODES.CLOSE_NORMAL
                })
              );
              log("error", "Socket.io connection to '" + this.url + "' failed");
            }
          }, this);
          this.addEventListener("close", function(event) {
            this$1.dispatchEvent(
              createCloseEvent({
                type: "disconnect",
                target: event.target,
                code: event.code
              })
            );
          });
        }
        if (EventTarget$$1) SocketIO.__proto__ = EventTarget$$1;
        SocketIO.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);
        SocketIO.prototype.constructor = SocketIO;
        var prototypeAccessors = { broadcast: {} };
        SocketIO.prototype.close = function close() {
          if (this.readyState !== SocketIO.OPEN) {
            return void 0;
          }
          var server = networkBridge.serverLookup(this.url);
          networkBridge.removeWebSocket(this, this.url);
          this.readyState = SocketIO.CLOSED;
          this.dispatchEvent(
            createCloseEvent({
              type: "close",
              target: this,
              code: CLOSE_CODES.CLOSE_NORMAL
            })
          );
          if (server) {
            server.dispatchEvent(
              createCloseEvent({
                type: "disconnect",
                target: this,
                code: CLOSE_CODES.CLOSE_NORMAL
              }),
              server
            );
          }
          return this;
        };
        SocketIO.prototype.disconnect = function disconnect() {
          return this.close();
        };
        SocketIO.prototype.emit = function emit(event) {
          var data = [], len = arguments.length - 1;
          while (len-- > 0) data[len] = arguments[len + 1];
          if (this.readyState !== SocketIO.OPEN) {
            throw new Error("SocketIO is already in CLOSING or CLOSED state");
          }
          var messageEvent = createMessageEvent({
            type: event,
            origin: this.url,
            data
          });
          var server = networkBridge.serverLookup(this.url);
          if (server) {
            server.dispatchEvent.apply(server, [messageEvent].concat(data));
          }
          return this;
        };
        SocketIO.prototype.send = function send(data) {
          this.emit("message", data);
          return this;
        };
        prototypeAccessors.broadcast.get = function() {
          if (this.readyState !== SocketIO.OPEN) {
            throw new Error("SocketIO is already in CLOSING or CLOSED state");
          }
          var self2 = this;
          var server = networkBridge.serverLookup(this.url);
          if (!server) {
            throw new Error("SocketIO can not find a server at the specified URL (" + this.url + ")");
          }
          return {
            emit: function emit(event, data) {
              server.emit(event, data, { websockets: networkBridge.websocketsLookup(self2.url, null, self2) });
              return self2;
            },
            to: function to(room) {
              return server.to(room, self2);
            },
            in: function in$1(room) {
              return server.in(room, self2);
            }
          };
        };
        SocketIO.prototype.on = function on(type, callback) {
          this.addEventListener(type, callback);
          return this;
        };
        SocketIO.prototype.off = function off(type, callback) {
          this.removeEventListener(type, callback);
        };
        SocketIO.prototype.hasListeners = function hasListeners(type) {
          var listeners = this.listeners[type];
          if (!Array.isArray(listeners)) {
            return false;
          }
          return !!listeners.length;
        };
        SocketIO.prototype.join = function join(room) {
          networkBridge.addMembershipToRoom(this, room);
        };
        SocketIO.prototype.leave = function leave(room) {
          networkBridge.removeMembershipFromRoom(this, room);
        };
        SocketIO.prototype.to = function to(room) {
          return this.broadcast.to(room);
        };
        SocketIO.prototype.in = function in$1() {
          return this.to.apply(null, arguments);
        };
        SocketIO.prototype.dispatchEvent = function dispatchEvent(event) {
          var this$1 = this;
          var customArguments = [], len = arguments.length - 1;
          while (len-- > 0) customArguments[len] = arguments[len + 1];
          var eventName = event.type;
          var listeners = this.listeners[eventName];
          if (!Array.isArray(listeners)) {
            return false;
          }
          listeners.forEach(function(listener) {
            if (customArguments.length > 0) {
              listener.apply(this$1, customArguments);
            } else {
              listener.call(this$1, event.data ? event.data : event);
            }
          });
        };
        Object.defineProperties(SocketIO.prototype, prototypeAccessors);
        return SocketIO;
      })(EventTarget);
      SocketIO$1.CONNECTING = 0;
      SocketIO$1.OPEN = 1;
      SocketIO$1.CLOSING = 2;
      SocketIO$1.CLOSED = 3;
      var IO = function ioConstructor(url, protocol) {
        return new SocketIO$1(url, protocol);
      };
      IO.connect = function ioConnect(url, protocol) {
        return IO(url, protocol);
      };
      var dedupe = function(arr) {
        return arr.reduce(function(deduped, b) {
          if (deduped.indexOf(b) > -1) {
            return deduped;
          }
          return deduped.concat(b);
        }, []);
      };
      function retrieveGlobalObject() {
        if (typeof window !== "undefined") {
          return window;
        }
        return typeof process === "object" && typeof __require === "function" && typeof global === "object" ? global : this;
      }
      var defaultOptions = {
        mock: true,
        verifyClient: null,
        selectProtocol: null
      };
      var Server$1 = (function(EventTarget$$1) {
        function Server2(url, options) {
          if (options === void 0) options = defaultOptions;
          EventTarget$$1.call(this);
          var urlRecord = new urlParse(url);
          if (!urlRecord.pathname) {
            urlRecord.pathname = "/";
          }
          this.url = urlRecord.toString();
          this.originalWebSocket = null;
          var server = networkBridge.attachServer(this, this.url);
          if (!server) {
            this.dispatchEvent(createEvent({ type: "error" }));
            throw new Error("A mock server is already listening on this url");
          }
          this.options = Object.assign({}, defaultOptions, options);
          if (this.options.mock) {
            this.mockWebsocket();
          }
        }
        if (EventTarget$$1) Server2.__proto__ = EventTarget$$1;
        Server2.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);
        Server2.prototype.constructor = Server2;
        Server2.prototype.mockWebsocket = function mockWebsocket() {
          var globalObj = retrieveGlobalObject();
          this.originalWebSocket = globalObj.WebSocket;
          globalObj.WebSocket = WebSocket$1;
        };
        Server2.prototype.restoreWebsocket = function restoreWebsocket() {
          var globalObj = retrieveGlobalObject();
          if (this.originalWebSocket !== null) {
            globalObj.WebSocket = this.originalWebSocket;
          }
          this.originalWebSocket = null;
        };
        Server2.prototype.stop = function stop(callback) {
          if (callback === void 0) callback = function() {
          };
          if (this.options.mock) {
            this.restoreWebsocket();
          }
          networkBridge.removeServer(this.url);
          if (typeof callback === "function") {
            callback();
          }
        };
        Server2.prototype.on = function on(type, callback) {
          this.addEventListener(type, callback);
        };
        Server2.prototype.off = function off(type, callback) {
          this.removeEventListener(type, callback);
        };
        Server2.prototype.close = function close(options) {
          if (options === void 0) options = {};
          var code = options.code;
          var reason = options.reason;
          var wasClean = options.wasClean;
          var listeners = networkBridge.websocketsLookup(this.url);
          networkBridge.removeServer(this.url);
          listeners.forEach(function(socket) {
            socket.readyState = WebSocket$1.CLOSED;
            socket.dispatchEvent(
              createCloseEvent({
                type: "close",
                target: socket.target,
                code: code || CLOSE_CODES.CLOSE_NORMAL,
                reason: reason || "",
                wasClean
              })
            );
          });
          this.dispatchEvent(createCloseEvent({ type: "close" }), this);
        };
        Server2.prototype.emit = function emit(event, data, options) {
          var this$1 = this;
          if (options === void 0) options = {};
          var websockets = options.websockets;
          if (!websockets) {
            websockets = networkBridge.websocketsLookup(this.url);
          }
          var normalizedData;
          if (typeof options !== "object" || arguments.length > 3) {
            data = Array.prototype.slice.call(arguments, 1, arguments.length);
            normalizedData = data.map(function(item) {
              return normalizeSendData(item);
            });
          } else {
            normalizedData = normalizeSendData(data);
          }
          websockets.forEach(function(socket) {
            var messageData = socket instanceof SocketIO$1 ? data : normalizedData;
            if (Array.isArray(messageData)) {
              socket.dispatchEvent.apply(
                socket,
                [createMessageEvent({
                  type: event,
                  data: messageData,
                  origin: this$1.url,
                  target: socket.target
                })].concat(messageData)
              );
            } else {
              socket.dispatchEvent(
                createMessageEvent({
                  type: event,
                  data: messageData,
                  origin: this$1.url,
                  target: socket.target
                })
              );
            }
          });
        };
        Server2.prototype.clients = function clients() {
          return networkBridge.websocketsLookup(this.url);
        };
        Server2.prototype.to = function to(room, broadcaster, broadcastList) {
          var this$1 = this;
          if (broadcastList === void 0) broadcastList = [];
          var self2 = this;
          var websockets = dedupe(broadcastList.concat(networkBridge.websocketsLookup(this.url, room, broadcaster)));
          return {
            to: function(chainedRoom, chainedBroadcaster) {
              return this$1.to.call(this$1, chainedRoom, chainedBroadcaster, websockets);
            },
            emit: function emit(event, data) {
              self2.emit(event, data, { websockets });
            }
          };
        };
        Server2.prototype.in = function in$1() {
          var args = [], len = arguments.length;
          while (len--) args[len] = arguments[len];
          return this.to.apply(null, args);
        };
        Server2.prototype.simulate = function simulate(event) {
          var listeners = networkBridge.websocketsLookup(this.url);
          if (event === "error") {
            listeners.forEach(function(socket) {
              socket.readyState = WebSocket$1.CLOSED;
              socket.dispatchEvent(createEvent({ type: "error", target: socket.target }));
            });
          }
        };
        return Server2;
      })(EventTarget);
      Server$1.of = function of(url) {
        return new Server$1(url);
      };
      var Server = Server$1;
      var WebSocket = WebSocket$1;
      var SocketIO$$1 = IO;
      exports2.Server = Server;
      exports2.WebSocket = WebSocket;
      exports2.SocketIO = SocketIO$$1;
      Object.defineProperty(exports2, "__esModule", { value: true });
    }));
  }
});
export default require_mock_socket();
//# sourceMappingURL=mock-socket.js.map
